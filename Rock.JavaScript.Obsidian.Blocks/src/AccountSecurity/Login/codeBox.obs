<template>
    <RockFormField
        v-model="internalModelValue"
        name="codebox"
        :rules="rules">
        <template #default="{uniqueId, field}">
            <div :class="['form-group rock-code-box', isRequired ? 'required' : '']">
                <div class="control-wrapper">
                    <div class="d-flex" ref="otpContainer">
                        <input
                            v-for="(character, index) in characters"
                            v-model="characters[index]"
                            autocomplete="one-time-code"
                            :autofocus="index === 0"
                            :class="`form-control flex-grow-1 flex-sm-grow-0 flex-shrink-1 ${index > 0 ? 'ml-1' : ''} h3`"
                            :disabled="disabled"
                            :id="`${uniqueId}-${index}`"
                            :key="`${character}${index}`"
                            maxlength="1"
                            type="text"
                            @keydown="onKeyDown($event, index)"
                            @paste.native="onPaste($event)" />
                    </div>
                </div>
            </div>
        </template>
    </RockFormField>
</template>

<style scoped>
.rock-code-box input {
    width: 47px;
    height: 64px;
    text-align: center;
    font-size: 24px;
}
</style>

<script setup lang="ts">
    import RockFormField from "@Obsidian/Controls/rockFormField";
    import { useVModelPassthrough } from "@Obsidian/Utility/component";
    import { normalizeRules, rulesPropType } from "@Obsidian/ValidationRules";
    import { ref, reactive, PropType, VNodeRef, computed } from "vue";

    type CodeBoxModelModifiers = {
        capitalize?: unknown
    };

    const props = defineProps({
        modelValue: {
            type: String as PropType<string>,
            required: false,
            default: null
        },

        allowedChars: {
            type: Object as PropType<RegExp>,
            required: false,
            default: /^[a-zA-Z0-9]$/
        },

        disabled: {
            type: Boolean as PropType<boolean>,
            required: false,
            default: false
        },

        updateOnComplete: {
            type: Boolean as PropType<boolean>,
            required: false,
            default: false
        },

        maxLength: {
            type: Number as PropType<number>,
            required: true
        },

        modelModifiers: {
            type: Object as PropType<CodeBoxModelModifiers>,
            required: false,
            default: null
        },

        rules: rulesPropType
    });

    const emit = defineEmits(["update:modelValue"]);

    const internalModelValue = useVModelPassthrough(props, "modelValue", emit);

    const characters = reactive<(string | null | undefined)[]>([]);

    if (props.modelValue && props.modelValue.length === props.maxLength) {
        for (let i =0; i < props.maxLength; i++) {
            characters[i] = props.modelValue.charAt(i);
        }
    }
    else {
        for (let i =0; i < props.maxLength; i++) {
            characters[i] = null;
        }
    }

    const otpContainer = ref<VNodeRef | undefined>(undefined);

    /** The internal rules we will be used for calculations. */
    const internalRules = computed(() => normalizeRules(props.rules));

    /** Determines if this field is marked as required. */
    const isRequired = computed(() => internalRules.value.includes("required"));

    function isOtpComplete(): boolean {
        for (const character of characters) {
            if (character == null || character == undefined) {
                return false;
            }
        }
        return true;
    }

    function onKeyDown(event: KeyboardEvent, index: number): void {
        if (event.ctrlKey || event.metaKey) {
            return;
        }

        if (event.key !== "Tab"
            && event.key !== "ArrowRight"
            && event.key !== "ArrowLeft"
            && event.key !== "Enter") {
            event.preventDefault();
        }

        if (event.key === "Backspace") {
            characters[index] = null;

            if (index !== 0) {
                (otpContainer.value.children)[index - 1].focus();
            }
            else {
                setTimeout(() => {
                    (otpContainer.value.children)[index].focus();
                }, 0);
            }
        }
        else {
            trySetCharacter(event.key, index);
        }

        tryEmitOtp();
    }

    function onPaste(event: ClipboardEvent): void {
        event.preventDefault();

        const pastedValue = event.clipboardData?.getData("text/plain").slice(0, props.maxLength) || " ".repeat(props.maxLength);

        for (let i = 0; i < props.maxLength; i++) {
            trySetCharacter(pastedValue.charAt(i), i);
        }

        tryEmitOtp();
    }

    function applyModifications(key: string): string {
        if (key && props.modelModifiers?.capitalize) {
            return key.toUpperCase();
        }

        return key;
    }

    function trySetCharacter(character: string, index: number): void {
        const modifiedCharacter = applyModifications(character);

        if (props.allowedChars.test(modifiedCharacter)) {
            characters[index] = modifiedCharacter;

            if (index !== props.maxLength - 1) {
                (otpContainer.value.children)[index + 1].focus();
            }
        }
    }

    function tryEmitOtp(): void {
        const isComplete = isOtpComplete();
        if (!props.updateOnComplete || isComplete) {
            emit("update:modelValue", characters.join(""));

            if (isComplete) {
                setTimeout(() => {
                    (otpContainer.value.children)[props.maxLength - 1].focus();
                }, 0);
            }
        }
    }
</script>
