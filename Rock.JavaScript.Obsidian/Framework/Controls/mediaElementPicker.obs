<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <RockFormField v-bind="formFieldProps" :modelValue="internalMediaElement" name="media-element-picker">
        <BaseAsyncPicker v-if="!hideAccountPicker" v-model="internalMediaAccount" v-bind="standardProps" label="Account" :items="mediaAccountItems" showBlankItem />
        <BaseAsyncPicker v-if="internalMediaAccount && !hideFolderPicker" v-model="internalMediaFolder" v-bind="standardProps" label="Folder" :items="mediaFolderItems" showBlankItem :lazyMode="ControlLazyMode.Eager">
            <template #inputGroupAppend v-if="!isRefreshDisallowed">
                <span class="input-group-addon">
                    <RockButton isSquare @click.prevent="fetchMediaFolders"><i class="fa fa-refresh"></i></RockButton>
                </span>
            </template>
        </BaseAsyncPicker>
        <BaseAsyncPicker v-if="internalMediaFolder && !hideMediaPicker" v-model="internalMediaElement" v-bind="standardProps" :label="mediaElementLabel" :items="mediaElementItems" showBlankItem :lazyMode="ControlLazyMode.Eager">
            <template #inputGroupAppend v-if="!isRefreshDisallowed">
                <span class="input-group-addon">
                    <RockButton isSquare @click.prevent="fetchMediaElements"><i class="fa fa-refresh"></i></RockButton>
                </span>
            </template>
        </BaseAsyncPicker>
    </RockFormField>
</template>

<script lang="ts" setup>
    import { computed, PropType, ref, watch } from "vue";
    import { standardRockFormFieldProps, useStandardAsyncPickerProps, standardAsyncPickerProps, useStandardRockFormFieldProps, updateRefValue } from "@Obsidian/Utility/component";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { MediaElementPickerGetMediaFoldersOptionsBag } from "@Obsidian/ViewModels/Rest/Controls/mediaElementPickerGetMediaFoldersOptionsBag";
    import { MediaElementPickerGetMediaElementsOptionsBag } from "@Obsidian/ViewModels/Rest/Controls/mediaElementPickerGetMediaElementsOptionsBag";
    import { HttpBodyData } from "@Obsidian/Types/Utility/http";
    import { ControlLazyMode } from "@Obsidian/Enums/Controls/controlLazyMode";
    import { useHttp } from "@Obsidian/Utility/http";
    import BaseAsyncPicker from "./baseAsyncPicker";
    import RockButton from "./rockButton";
    import RockFormField from "./rockFormField";

    const props = defineProps({
        ...standardRockFormFieldProps,

        modelValue: {
            type: Object as PropType<ListItemBag>,
            required: true
        },

        // v-model of the account
        account: {
            type: Object as PropType<ListItemBag>,
            default: null
        },

        // v-model of the folder
        folder: {
            type: Object as PropType<ListItemBag>,
            default: null
        },

        /** Whether to hide the media account dropdown portion */
        hideAccountPicker: {
            type: Boolean,
            default: false
        },

        /** Whether to hide the media folder dropdown portion */
        hideFolderPicker: {
            type: Boolean,
            default: false
        },

        /** Whether to hide the media element dropdown portion */
        hideMediaPicker: {
            type: Boolean,
            default: false
        },

        isRefreshDisallowed: {
            type: Boolean,
            default: false
        },

        mediaElementLabel: {
            type: String,
            default: "Media"
        },

        ...standardAsyncPickerProps
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: ListItemBag | null): void
        (e: "update:account", value: ListItemBag | null): void
        (e: "update:folder", value: ListItemBag | null): void
    }>();

    // #region Values

    const internalMediaAccount = ref<ListItemBag | null>(props.account);
    const internalMediaFolder = ref<ListItemBag | null>(props.folder);
    const internalMediaElement = ref<ListItemBag | null>(props.modelValue);

    const mediaAccountItems = ref<(() => Promise<ListItemBag[]>) | ListItemBag[] | null>(null);
    const mediaFolderItems = ref<(() => Promise<ListItemBag[]>) | ListItemBag[] | null>(null);
    const mediaElementItems = ref<(() => Promise<ListItemBag[]>) | ListItemBag[] | null>(null);

    const standardProps = useStandardAsyncPickerProps(props);
    const formFieldProps = useStandardRockFormFieldProps(props);

    const http = useHttp();

    // #endregion

    // #region Functions

    async function loadItems(apiAction: string, payload: HttpBodyData = null): Promise<ListItemBag[]> {
        const result = await http.post<ListItemBag[]>("/api/v2/Controls/" + apiAction, undefined, payload);

        if (result.isSuccess && result.data) {
            return result.data;
        }
        else {
            console.error(result.errorMessage ?? "Unknown error while loading data.");
            return [];
        }
    }

    async function loadMediaAccounts(): Promise<ListItemBag[]> {
        return loadItems("MediaElementPickerGetMediaAccounts");
    }

    async function loadMediaFolders(): Promise<ListItemBag[]> {
        const options: MediaElementPickerGetMediaFoldersOptionsBag = {
            mediaAccountGuid: internalMediaAccount.value?.value ?? null
        };

        return loadItems("MediaElementPickerGetMediaFolders", options);
    }

    async function loadMediaElements(): Promise<ListItemBag[]> {
        const options: MediaElementPickerGetMediaElementsOptionsBag = {
            mediaFolderGuid: internalMediaFolder.value?.value ?? null
        };

        return loadItems("MediaElementPickerGetMediaElements", options);
    }

    function fetchMediaAccounts(): void {
        mediaAccountItems.value = () => loadMediaAccounts();
    }
    function fetchMediaFolders(): void {
        mediaFolderItems.value = () => loadMediaFolders();
    }
    function fetchMediaElements(): void {
        mediaElementItems.value = () => loadMediaElements();
    }

    // #endregion

    // #region Computed

    const hideAccountPicker = computed<boolean>(() => {
        // Only hide the account picker when the prop says we should AND we have an account selected
        return props.hideAccountPicker && internalMediaAccount.value != null;
    });

    const hideFolderPicker = computed<boolean>(() => {
        // Only hide the account picker when the prop says we should AND we have an account selected
        return props.hideFolderPicker && internalMediaFolder.value != null;
    });

    // #endregion

    // #region Watchers

    watch(internalMediaAccount, () => {
        console.debug("ACCOUNT CHANGED");
        internalMediaFolder.value = null;
        emit("update:account", internalMediaAccount.value);
        fetchMediaFolders();
    });
    watch(internalMediaFolder, () => {
        console.debug("FOLDER CHANGED");
        internalMediaElement.value = null;
        emit("update:folder", internalMediaFolder.value);
        fetchMediaElements();
    });
    watch(internalMediaElement, () => {
        console.debug("ELEMENT CHANGED");
        emit("update:modelValue", internalMediaElement.value);
    });



    watch(() => props.account, () => {
        console.debug("ACCOUNT PROP CHANGED");
        if (updateRefValue(internalMediaAccount, props.account)) {
            // Prop value is different than current value... need updates from server
        }
    });
    watch(() => props.folder, () => {
        console.debug("FOLDER PROP CHANGED");
        if (updateRefValue(internalMediaFolder, props.folder)) {
            // Prop value is different than current value... need updates from server
        }
    });
    watch(() => props.modelValue, () => {
        console.debug("ELEMENT PROP CHANGED");
        if (updateRefValue(internalMediaElement, props.modelValue)) {
            // Prop value is different than current value... need updates from server
        }
    });

    // #endregion

    fetchMediaAccounts();
</script>
